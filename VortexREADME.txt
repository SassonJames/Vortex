Project 2: Vortex
by Jamie Sasson

What's the App Do?
	This app is a simple game where players use gravity to collect gems. There is no gem limit, but all players are fighting for the same gems. The purpose of the app is to demonstrate interesting physics and hopefully encourage competition over the gems.
	Going in depth, the actual client side of the app creates a ball called a 'retriever' that will spin around a vortex until eventually it gets deleted in the center. The client simply draws what the server tells it to draw and tells the server when it has launched it's ball. I go more in depth about what the server does in the web sockets section, but briefly it handles all the physics and collisions.

What are Websockets used for in this project?
	This time, the server is specifically handling all the physics calculations as well as collision calculations. There are 4 main components to the physics that I will go over individually here.
	Vortex Velocity: Every 20 milliseconds, the server will update each retriever that it has on screen's velocity. The velocity calculation draws the retrievers to the center and creates a familiar circular pattern. The vortex is a bit more random, however, and it does not create a perfect circle (this is intentional as watching coins spin down a funnel gets boring). The randomness can allow players to potentially collect a lot of gems, but risk missing many. There are many safe launch positions that funnel directly into the center, but these usually only collect one gem.
	Eye of the Storm: I realize I'm naming these in a funny way, but it makes sense for the game. The eye of the storm is one of the collisions that is programmed into the server. When a retriever approaches the eye of the storm, or the center of the vortex, it will disappear and reset for the player. Each player can only have one retriever, so it is important to let them launch it again. The collision is a simple distance formula based on the circle's radius.
	Gem Generation: Every time a new player starts the game, 2 gems will be created for them. This functionality will make sure that there is always 2*NumPlayers gems. This updates every 3 seconds. This serves to entice players to get more people to play the game, as more gems creates more chaos. However, when there is fewer players the gems are less dense so it becomes more of a skill game. The variable gem generation works to control how the game feels.
	Gem Collision: The most simple mechanic is also the most important. The server will check if any players have collided with the gems, if they have the gem will be removed and the player will gain a point. This also uses a distance formula built into the server and is a simple circle collision.
	What I find impressive is how smoothly this code runs. There are hardly any hiccups despite the constant velocity updates and collision checks. I credit this to the updates only happening when absolutely necessary and not once a millisecond. There is a balance between frequency and effeiciency and I think I did pretty well with it here.

What went Right?
	I'm really happy with the efficiency of the application. It runs smoothly and is honestly kinda fun to play. I thought this would be pretty simple when it was done, but the variance of the vortex makes every attempt to get gems more interesting than I thought it would be. I also think that the core concept was pretty strong. A gravity based collection mini game sounds fun and I'm pretty sure there is something similar in a Mario Party game. (not that I stole it, I honestly don't know). I also like that the client only has to handle sending the initial retriever and updating the draws. This makes it very light on the client side, which in turn makes computers not hate my code.

What went Wrong?
	Well, initially I wanted to create a Hungry Hungry Hippos clone where players could scoop up balls and earn points, but handling the collisions was far more taxing than I anticipated, so I decided to scale down. This is much simpler than I wanted it to be, and I think that helps me moving forward with scope. I also had some major issues with the efficiency of the code originally. When I first started the server, it was chugging really bad and I wasn't sure why. It turns out I was sending multiple retrievers as ghost objects and all of them had to be drawn first. It took me a few days to figure out. The gravity for the vortex was also a challenge. Gravity that isn't just pointed down is complicated and getting it to act correctly is difficult. I'm still not entirely happy with how it acts, but it is in an interesting state and I think the game is better because of it.

What could be Improved?
	Player on Player collision would definitely be the next step for the project. It would make where the player launches the ball matter that much more. I also think variable launch angles would be a great thing to implement. Right now you only fire straight from the perimeter, which is fine, but having the varied launching angles could make some interesting game play. That would be much harder than player collisions, as angular velocity is harder to implement, especially as an impulse, but that's where I'd want to head. I don't think power ups are necessary, though an 'End State' or 'Victory Condition' could be good.

Above and Beyond?
	I think I did this in two ways, one is kind of invisible and the other is more of a technical challenge that I took on. I'll explain the both below.
	Vortex Gravity: The vortex mechanic of this game was pretty difficult to implement and also not something that was necessary. I could have had the players just launch from the top and collide with pegs while on their way to the bottom, plinko style, but I wanted to have another dimension to the game play. The vortex and velocity calculations are complicated and really add to the overall game play of the game (hence why I named it Vortex).
	Efficiency: Now, I'm not saying that this scales infinitely and I'm not asking you to D-Dos my app, but I am pretty happy with how it turned on efficiency wise enough to put it here. The app can handle a lot of players simultaneously without signs of slowing down, which I think is pretty great considering the number of calculations I'm doing. I wouldn't say that this is a big Above and Beyond, but I'm proud of it non-the-less.


